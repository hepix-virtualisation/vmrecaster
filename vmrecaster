#!/usr/bin/env python
import sys
if sys.version_info < (2, 4):
    print "Your python interpreter is too old. Please consider upgrading."
    sys.exit(1)

import os
import logging
import optparse
import hashlib
import datetime
try:
    import simplejson as json
except:
    import json
import time
import datetime

import time
import subprocess

from VmRecast.__version__ import version

import VmRecast.recastDb as recastdb

time_format_definition = "%Y-%m-%dT%H:%M:%SZ"


from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
import datetime


EnvEventType = ['']
EnvEvent = set(['VMCATCHER_EVENT_TYPE',
    'VMCATCHER_EVENT_DC_DESCRIPTION',
    'VMCATCHER_EVENT_DC_IDENTIFIER',
    'VMCATCHER_EVENT_DC_TITLE',
    'VMCATCHER_EVENT_HV_HYPERVISOR',
    'VMCATCHER_EVENT_HV_FORMAT',
    'VMCATCHER_EVENT_HV_SIZE',
    'VMCATCHER_EVENT_HV_URI',
    'VMCATCHER_EVENT_SL_ARCH',
    'VMCATCHER_EVENT_SL_CHECKSUM_SHA512',
    'VMCATCHER_EVENT_SL_COMMENTS',
    'VMCATCHER_EVENT_SL_OS',
    'VMCATCHER_EVENT_SL_OSVERSION',
    'VMCATCHER_EVENT_TYPE',
    'VMCATCHER_EVENT_FILENAME'])
    
EnvConf = set(['VMCATCHER_RDBMS',
    'VMCATCHER_CACHE_EVENT',
    'VMCATCHER_LOG_CONF',
    'VMCATCHER_DIR_CERT',
    'VMCATCHER_CACHE_DIR_CACHE',
    'VMCATCHER_CACHE_DIR_DOWNLOAD',
    'VMCATCHER_CACHE_DIR_EXPIRE',
    'VMCATCHER_EVENT_UUID_SESSION'])

EnvConfInteresting = EnvEvent.union(EnvConf)

def runcommand(cmd = "voms-proxy-info  --all",timeout=0, cwd =None):
    process = subprocess.Popen([cmd], shell=True, cwd = cwd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    processRc = None
    handleprocess = True
    counter = 0
    stdout = ''
    stderr = ''
    while handleprocess:
        counter += 1
        time.sleep(1)
        cout,cerr = process.communicate()
        stdout += cout
        stderr += cerr
        process.poll()
        processRc = process.returncode
        if processRc != None:
            break
        if counter == timeout:
            os.kill(process.pid, signal.SIGQUIT)
        if counter > timeout:
            os.kill(process.pid, signal.SIGKILL)
            processRc = -9
            break
    return processRc , stdout, stderr
    

uuidtrwawnsform = {
'aa7016b0-6508-41d2-bce0-c1724cb3d3e2' : '16ea5937-c8f4-4754-8376-f898b12de731',
'aa42ca85-179b-4873-b12e-32d549bf02b6' : '016fc535-f946-4473-98b2-5075a4e2e015',
}






def generateEnvDict(enviromentDict = os.environ):
    FoundEnviroment = {}
    for key in EnvConfInteresting:
        if key in enviromentDict.keys():
            FoundEnviroment[key] = enviromentDict[key]
    return FoundEnviroment

def nullEnvDict(enviromentDict = generateEnvDict(),NullValue = ""):
    FoundEnviroment = enviromentDict.copy()
    enviromentKeysSet = set(FoundEnviroment.keys())
    missing = EnvConfInteresting.difference(enviromentKeysSet)
    for item in missing:
        FoundEnviroment[item] = NullValue
    return FoundEnviroment



def getImageDetails(uuid):
    log = logging.getLogger("getImageDetails")
    cmd = """vmcaster \
    --show-image \
    --select-image %s""" % (
        uuid
    )
    
    log.info("Attempting '%s'" % (cmd))
    rc,stdout,stderr = runcommand(cmd)
    if rc != 0:
        log.error("Failed Running command:%s" % (cmd))
        if len(stdout) > 0:
            log.info("stdout:%s" % (stdout))
        if len(stderr) > 0:
            log.info("stderr:%s" % (stderr))
        return None
    return stdout

def handleEvent():
    log = logging.getLogger("handleEvent")
    eventKey = ''
    
    uuidKey = 'VMCATCHER_EVENT_DC_IDENTIFIER'
    if not uuidKey in os.environ.keys():
        log.error("no VMCATCHER_EVENT_DC_IDENTIFIER")
        return False
        
    uuidInput = os.environ[uuidKey]
    cacheDirKey = 'VMCATCHER_CACHE_DIR_CACHE'
    if not cacheDirKey in os.environ.keys():
        log.error("no VMCATCHER_CACHE_DIR_CACHE")
        return False
    cacheDir = os.environ[cacheDirKey]
    cacheFileNameKey = 'VMCATCHER_EVENT_FILENAME'
    if not cacheFileNameKey in os.environ.keys():
        log.error("no VMCATCHER_EVENT_FILENAME")
        return False
    cacheFileName = os.environ[cacheFileNameKey]
    if not uuidInput in uuidtrwawnsform.keys():
        log.info("not important uuid")
        return True
    uuid = uuidtrwawnsform[uuidInput]
    cacheFileName = os.environ[cacheFileNameKey]
    matchingfiles = "%s/%s" % (cacheDir,cacheFileName)
    print matchingfiles
    
    
    imagedetailsBefore = getImageDetails(uuid)
    
    
    cmd = """vmcaster \
    --upload-image %s \
    --select-image %s""" % (
        matchingfiles,
        uuid
    )
    
    log.info("Attempting '%s'" % (cmd))
    rc,stdout,stderr = runcommand(cmd)
    if rc != 0:
        log.error("Failed Running command:%s" % (cmd))
    if len(stdout) > 0:
        log.info("stdout:%s" % (stdout))
    if len(stderr) > 0:
        log.info("stderr:%s" % (stderr))
    
    imagedetailsAfter = getImageDetails(uuid)
    
    if imagedetailsBefore == imagedetailsAfter:
        log.info("Image unchanged")
        return
    
    
    
    output = stdout + stderr
    print cmd
    with open("/tmp/dingf", "a") as myfile:
            myfile.write(output)
            myfile.write('\n')


def checkEnvToDict(RequiredEnv):
    log = logging.getLogger("minenv")
    output = {}
    for envKey in RequiredEnv:
        if not envKey in os.environ.keys():
            log.error("no %s enviroment variable." % (envKey))
            return None
        output[envKey] = os.environ[envKey]
    return output


class handler():

    def initDb(self):
        if self.databaseConnectionString == None:
            return False
        self.engine = create_engine(self.databaseConnectionString, echo=False)
        recastdb.init(self.engine)
        self.SessionFactory = sessionmaker(bind=self.engine)
        return True
        
    def fuctAvailablePrefix(self):
        log = logging.getLogger("fuctAvailablePrefix")
        RequiredEnv = [
                "VMCATCHER_EVENT_UUID_SESSION",
                "VMCATCHER_EVENT_DC_IDENTIFIER",
            ]
        NeededEvents = checkEnvToDict(RequiredEnv)
        if NeededEvents == None:
            return 1
        dbInitrc = self.initDb()
        if dbInitrc != True:
            return 2
        # Check for a mapping
        session = self.SessionFactory()
        qryMapping  = session.query(recastdb.ImageUuidMapping).\
            filter(recastdb.ImageUuidMapping.imageUuidSrc == NeededEvents["VMCATCHER_EVENT_DC_IDENTIFIER"])
        countMapping = int(qryMapping.count())
        
        log.info("nullEnvDict=%s"  % ( nullEnvDict()))
        if countMapping == 0:
            log.info("No mapping for:'%s'" % (NeededEvents["VMCATCHER_EVENT_DC_IDENTIFIER"]))
            return 0
        # Check for a session
        qrySession = session.query(recastdb.Session).\
            filter(recastdb.Session.uuid == NeededEvents["VMCATCHER_EVENT_UUID_SESSION"])
        countSession = int(qrySession.count())
        if countSession != 1:
            log.error("Session %s has not started" % (NeededEvents["VMCATCHER_EVENT_UUID_SESSION"]))
            return 3
        thisEventSession = qrySession.one()
        
        return 0

    def fuctAvailablePostfix(self):
        log = logging.getLogger("fuctAvailablePostfix")
        RequiredEnv = [
                "VMCATCHER_EVENT_UUID_SESSION",
                "VMCATCHER_EVENT_DC_IDENTIFIER",
            ]
        NeededEvents = checkEnvToDict(RequiredEnv)
        if NeededEvents == None:
            return 1
        dbInitrc = self.initDb()
        if dbInitrc != True:
            return 2
        # Check for a mapping
        session = self.SessionFactory()
        qryMapping  = session.query(recastdb.ImageUuidMapping).\
            filter(recastdb.ImageUuidMapping.imageUuidSrc == NeededEvents["VMCATCHER_EVENT_DC_IDENTIFIER"])
        countMapping = int(qryMapping.count())
        
        log.info("nullEnvDict=%s"  % ( nullEnvDict()))
        if countMapping == 0:
            log.info("No mapping for:'%s'" % (NeededEvents["VMCATCHER_EVENT_DC_IDENTIFIER"]))
            return 0
        # Check for a session
        qrySession = session.query(recastdb.Session).\
            filter(recastdb.Session.uuid == NeededEvents["VMCATCHER_EVENT_UUID_SESSION"])
        countSession = int(qrySession.count())
        if countSession != 1:
            log.error("Session %s has not started" % (NeededEvents["VMCATCHER_EVENT_UUID_SESSION"]))
            return 3
        thisEventSession = qrySession.one()
        
        return 0

    def fuctExpirePrefix(self):
        log = logging.getLogger("fuctExpirePrefix")
        RequiredEnv = [
                "VMCATCHER_EVENT_UUID_SESSION",
                "VMCATCHER_EVENT_DC_IDENTIFIER",
            ]
        NeededEvents = checkEnvToDict(RequiredEnv)
        if NeededEvents == None:
            return 1
        dbInitrc = self.initDb()
        if dbInitrc != True:
            return 2
        # Check for a mapping
        session = self.SessionFactory()
        qryMapping  = session.query(recastdb.ImageUuidMapping).\
            filter(recastdb.ImageUuidMapping.imageUuidSrc == NeededEvents["VMCATCHER_EVENT_DC_IDENTIFIER"])
        countMapping = int(qryMapping.count())
        
        log.info("nullEnvDict=%s"  % ( nullEnvDict()))
        if countMapping == 0:
            log.info("No mapping for:'%s'" % (NeededEvents["VMCATCHER_EVENT_DC_IDENTIFIER"]))
            return 0
        # Check for a session
        qrySession = session.query(recastdb.Session).\
            filter(recastdb.Session.uuid == NeededEvents["VMCATCHER_EVENT_UUID_SESSION"])
        countSession = int(qrySession.count())
        if countSession != 1:
            log.error("Session %s has not started" % (NeededEvents["VMCATCHER_EVENT_UUID_SESSION"]))
            return 3
        thisEventSession = qrySession.one()
        
        return 0

    def fuctExpirePostfix(self):
        log = logging.getLogger("fuctExpirePostfix")
        RequiredEnv = [
                "VMCATCHER_EVENT_UUID_SESSION",
                "VMCATCHER_EVENT_DC_IDENTIFIER",
            ]
        NeededEvents = checkEnvToDict(RequiredEnv)
        if NeededEvents == None:
            return 1
        dbInitrc = self.initDb()
        if dbInitrc != True:
            return 2
        # Check for a mapping
        session = self.SessionFactory()
        qryMapping  = session.query(recastdb.ImageUuidMapping).\
            filter(recastdb.ImageUuidMapping.imageUuidSrc == NeededEvents["VMCATCHER_EVENT_DC_IDENTIFIER"])
        countMapping = int(qryMapping.count())
        
        log.info("nullEnvDict=%s"  % ( nullEnvDict()))
        if countMapping == 0:
            log.info("No mapping for:'%s'" % (NeededEvents["VMCATCHER_EVENT_DC_IDENTIFIER"]))
            return 0
        # Check for a session
        qrySession = session.query(recastdb.Session).\
            filter(recastdb.Session.uuid == NeededEvents["VMCATCHER_EVENT_UUID_SESSION"])
        countSession = int(qrySession.count())
        if countSession != 1:
            log.error("Session %s has not started" % (NeededEvents["VMCATCHER_EVENT_UUID_SESSION"]))
            return 3
        thisEventSession = qrySession.one()
        
        
        return 0


    def fuctProcessPrefix(self):
        log = logging.getLogger("fuctProcessPrefix")
        RequiredEnv = [
                "VMCATCHER_EVENT_UUID_SESSION",
            ]
        NeededEvents = checkEnvToDict(RequiredEnv)
        if NeededEvents == None:
            return 1
        dbInitrc = self.initDb()
        if dbInitrc != True:
            return 2
        session = self.SessionFactory()
        qrySession = session.query(recastdb.Session).\
            filter(recastdb.Session.uuid == NeededEvents["VMCATCHER_EVENT_UUID_SESSION"])
        countSession = int(qrySession.count())
        if countSession != 0:
            log.error("Session %s already happened" % (NeededEvents["VMCATCHER_EVENT_UUID_SESSION"]))
            return 3
        now = datetime.datetime.utcnow()
        eventSession = recastdb.Session(uuid=NeededEvents["VMCATCHER_EVENT_UUID_SESSION"],created=now)
        session.add(eventSession)
        session.commit()
        return 0

    def fuctProcessPostfix(self):
        log = logging.getLogger("fuctProcessPostfix")
        RequiredEnv = [
                "VMCATCHER_EVENT_UUID_SESSION",
            ]
        NeededEvents = checkEnvToDict(RequiredEnv)
        if NeededEvents == None:
            return 1
        dbInitrc = self.initDb()
        if dbInitrc != True:
            return 2
        session = self.SessionFactory()
        qrySession = session.query(recastdb.Session).\
            filter(recastdb.Session.uuid == NeededEvents["VMCATCHER_EVENT_UUID_SESSION"])
        countSession = int(qrySession.count())
        if countSession != 1:
            log.error("Session %s has not started" % (NeededEvents["VMCATCHER_EVENT_UUID_SESSION"]))
            return 3
        thisEventSession = qrySession.one()
        #now = datetime.datetime.utcnow()
        #runtime = (now - thisEventSession.created)
        print thisEventSession.id
        session.delete(thisEventSession)
        session.commit()
        return 0
class admin():

    def initDb(self):
        if self.databaseConnectionString == None:
            return False
        self.engine = create_engine(self.databaseConnectionString, echo=False)
        recastdb.init(self.engine)
        self.SessionFactory = sessionmaker(bind=self.engine)
        return True
    def add_map(self,*args, **kwargs):
        log = logging.getLogger("add_map")
        mapImageDstUuid = kwargs.get('mapImageDstUuid', None)
        mapImageListDstUuid = kwargs.get('mapImageListDstUuid', None)
        mapImageSrcUuid = kwargs.get('mapImageSrcUuid', None)
        session = self.SessionFactory()
        qryImageUuidMapping = session.query(recastdb.ImageUuidMapping).\
            filter(recastdb.ImageUuidMapping.imageUuidDest == mapImageDstUuid)
        if 0 != qryImageUuidMapping.count():
            log.error("Map already exists %s" % (qryImageUuidMapping.one()))
            return 3
        newmap = recastdb.ImageUuidMapping(
               imageUuidDest = mapImageDstUuid,
               imagelistUuidDest = mapImageListDstUuid,
               imageUuidSrc = mapImageSrcUuid,
            )
        session.add(newmap)
        session.commit()
def main():
    reload(sys)
    sys.setdefaultencoding('utf-8')
    log = logging.getLogger("main")
    p = optparse.OptionParser(version = "%prog " + version)    
    p.add_option('-d', '--database', action ='store', help='Database conection string')
    p.add_option('--output_file', action ='store',help='Output file to log event.', metavar='OUTPUT_LOGFILE')
    p.add_option('--generator',  action ='store',help='Set the dictionary Generator.', metavar='minium')
    p.add_option('--datetime',  action ='store_true',help='Add a datetime stamp.')
    p.add_option('-v','--verbose', action ='count',help='Change global log level, increasing log output.', metavar='LOGFILE')
    p.add_option('-q','--quiet', action ='count',help='Change global log level, decreasing log output.', metavar='LOGFILE')
    p.add_option('--logcfg', action ='store',help='Logfile configuration file.', metavar='CFG_LOGFILE')
    p.add_option('--list-map', action ='store_true',help='add an image mapping.')
    p.add_option('--add-map', action ='store_true',help='add an image mapping.')
    p.add_option('--del-map', action ='store_true',help='delete an image mapping.')
    p.add_option('--map', action ='store',help='select map image')
    p.add_option('--src', action ='store',help='select source image.')
    p.add_option('--list', action ='store',help='select map image list.')
    
    
    
    
    
    options, arguments = p.parse_args()
    actions = []
    databaseConnectionString = None
    mapImageDstUuid = None
    mapImageListDstUuid = None
    mapImageSrcUuid = None
    
    
    
    
    if 'VMRECASTER_RDBMS' in os.environ:
        databaseConnectionString = os.environ['VMRECASTER_RDBMS']
    
    # Set up log file
    
    LoggingLevel = logging.WARNING
    LoggingLevelCounter = 3
    if options.verbose:
        LoggingLevelCounter = LoggingLevelCounter - options.verbose
        if options.verbose == 1:
            LoggingLevel = logging.INFO
        if options.verbose == 2:
            LoggingLevel = logging.DEBUG
    if options.quiet:
        LoggingLevelCounter = LoggingLevelCounter + options.quiet
    if LoggingLevelCounter <= 0:
        LoggingLevel = logging.DEBUG
    if LoggingLevelCounter == 1:
        LoggingLevel = logging.INFO
    if LoggingLevelCounter == 2:
        LoggingLevel = logging.WARNING
    if LoggingLevelCounter == 3:
        LoggingLevel = logging.ERROR
    if LoggingLevelCounter == 4:
        LoggingLevel = logging.FATAL
    if LoggingLevelCounter >= 5:
        LoggingLevel = logging.CRITICAL
    logFile = None
    if options.logcfg:
        logFile = options.logcfg
    if logFile != None:
        if os.path.isfile(str(options.log_config)):
            logging.config.fileConfig(options.log_config)
        else:
            logging.basicConfig(level=LoggingLevel)
            log = logging.getLogger("main")
            log.error("Logfile configuration file '%s' was not found." % (options.log_config))
            sys.exit(1)
    else:
        
        logging.basicConfig(level=LoggingLevel)
    log = logging.getLogger("main")
    outputDict = None
    generator = nullEnvDict()
    if options.generator:
        if options.generator == "minium":
            generator = generateEnvDict()
    if options.datetime:
        generator['DATETIME'] = datetime.datetime.now().strftime(time_format_definition)
    if options.output_file:
        with open(options.output_file, "a") as myfile:
            json.dump(generator, myfile, sort_keys=True)
            myfile.write('\n')
    if options.add_map:
        actions.append("add_map")
    if options.src:
        mapImageSrcUuid = options.src
    if options.list:
        mapImageListDstUuid = options.list
    if options.map:
        mapImageDstUuid = options.map
    #handleEvent()
    if options.database:
        databaseConnectionString = options.database
    
    
    
    if databaseConnectionString == None:
        databaseConnectionString = 'sqlite:///vmrecaster.db'
        log.info("Defaulting DB connection to '%s'" % (databaseConnectionString))
    
    
    if len(actions) == 0:
        typeKey = 'VMCATCHER_EVENT_TYPE'
        if not typeKey in os.environ.keys():
            log.error("no VMCATCHER_EVENT_DC_IDENTIFIER enviroment variable.")
            return 1
        eventType = os.environ[typeKey]

        log.debug("VMCATCHER_EVENT_TYPE=%s" % (eventType))
        processor = handler()
        functionDict = {
            "AvailablePrefix" : processor.fuctAvailablePrefix,
            "AvailablePrefix" : processor.fuctAvailablePrefix,
            "ExpirePrefix" : processor.fuctExpirePrefix,
            "ProcessPrefix" : processor.fuctProcessPrefix,
            "AvailablePostfix" : processor.fuctAvailablePostfix,
            "ProcessPostfix" : processor.fuctProcessPostfix,
            "ExpirePostfix" : processor.fuctExpirePostfix,
            "ExpirePosfix" : processor.fuctExpirePostfix,
        }
        processor.databaseConnectionString = databaseConnectionString
        rc = functionDict[eventType]()

        log.debug("return code=%s" % (rc))
        return rc
    
    if "add_map" in actions:
        adminObj = admin()
        adminObj.databaseConnectionString = databaseConnectionString
        adminObj.initDb()
        adminObj.add_map(
                mapImageDstUuid= mapImageDstUuid,
                mapImageListDstUuid = mapImageListDstUuid,
                mapImageSrcUuid = mapImageSrcUuid,
            )
    
    
if __name__ == "__main__":
    
    main()

